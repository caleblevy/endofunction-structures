"""Module for computing conjugacy classes of self mappings on floating point
numbers.

Caleb Levy, 2015.
"""

import numbers

import numpy as np

from funcstructs import *

__all__ = [
    "FloatSet",
    "Inf", "Zero", "One", "NaN", "Min16", "Max16",
    "Positives", "Negatives", "FinitePositives", "FiniteNegatives",
    "NonPositives", "NonNegatives", "FiniteNonPositives", "FiniteNonNegatives",
    "UnitInterval", "Finites", "NonNan", "Floats"
]


Inf = np.float16('inf')
NaN = np.float16('nan')
Max16 = np.float16(65504.0)
Min16 = -Max16
Zero = np.float16(0)
One = np.float16(1)


def nextfloat(f):
    return np.nextafter(f, Inf, dtype=np.float16)


def prevfloat(f):
    return np.nextafter(f, -Inf, dtype=np.float16)


class FloatSet(tuple):
    """tuple of floats with constant time membership testing"""
    def __init__(self, _):
        self._elems = frozenset(self)

        if len(self._elems) != len(self):
            raise ValueError("Elements of float domain must be unique")
        if not all(type(f) is np.float16 for f in self):
            raise TypeError("FloatSet must contain float16")

        self._intmap = {}
        for i, f in enumerate(self):  # Create the inverse map
            self._intmap[f] = i

    def __contains__(self, item):
        return item in self._elems

    def __add__(self, other):
        return self.__class__(tuple(self) + tuple(other))

    def __radd__(self, other):
        return self.__class__(tuple(other) + tuple(self))

    def __getitem__(self, key):
        if isinstance(key, np.float16):
            return self._intmap[key]
        elif isinstance(key, slice):
            return self.__class__(super(FloatSet, self).__getitem__(key))
        return super(FloatSet, self).__getitem__(key)  # integer case

    # python2 compatibility function
    def __getslice__(self, start, stop):
        return self.__class__(super(FloatSet, self).__getslice__(start, stop))

    def conj(self, f):
        """Conjugate func into integer domain"""
        _sentinal = object()
        fi = [_sentinal] * len(self)
        for x, y in f.items():
            try:
                fi[self[x]] = self[y]
            except KeyError:
                if np.isnan(y):
                    fi[self[x]] = self[NaN]
                else:
                    raise
        if _sentinal in fi:
            raise ValueError("Incompatible domains")
        return rangefunc(fi)

    def endofunction(self, mapping):
        """Make endofunction from mapping applied to the domain"""
        f = {}
        for x in self:
            f[x] = mapping(x)
        return self.conj(f)

    def structure(self, mapping):
        """Return structure of endofunction generated by mapping"""
        return Funcstruct.from_func(self.endofunction(mapping))


Negatives = [-Inf]
f = Min16
while f < Zero:
    Negatives.append(f)
    f = nextfloat(f)
Negatives = FloatSet(Negatives)

f = nextfloat(Zero)
Positives = [f]
while f < Max16:
    f = nextfloat(f)
    Positives.append(f)
del f

Positives.append(Inf)
Positives = FloatSet(Positives)

NonPositives = Negatives + (Zero, )
NonNegatives = (Zero, ) + Positives

FinitePositives = Positives[:-1]
FiniteNonNegatives = NonNegatives[:-1]
FiniteNegatives = Negatives[1:]
FiniteNonPositives = NonPositives[1:]

UnitInterval = NonNegatives[:NonNegatives[One]+1]
Finites = FiniteNegatives + FiniteNonNegatives
NonNan = Negatives + NonNegatives
Floats = (NaN, ) + NonNan
