import unittest

from funcstructs.structures import(
    TreeEnumerator, ForestEnumerator, PartitionForests,
    EndofunctionStructures, TransformationMonoid,
    FixedContentNecklaces
)
from funcstructs.structures.multiset import Multiset
from .._enumerable import Enumerable, parametrize


# Test class for ParametrizedABC


@parametrize("start", "stop")
class Range(Enumerable):
    """Imitates range"""

    def __new__(cls, start, stop=100):
        return super(Range, cls).__new__(cls, start=start, stop=stop)

    def __iter__(self):
        return iter(range(self.start, self.stop))


@parametrize("step")
class StepRange(Range):

    def __new__(cls, start, stop=100, step=2):
        return super(Range, cls).__new__(cls, start=start, stop=stop,
                                         step=step)

    def __iter__(self):
        return iter(range(self.start, self.stop, self.step))


class ParametrizationTests(unittest.TestCase):

    def test_init(self):
        sr = StepRange(40)
        self.assertEqual(list(range(40, 100, 2)), list(sr))

    def test_dynamic_properties(self):
        """Test that the properties are correctly generated by ParamABC"""
        self.assertIsInstance(StepRange.start, property)
        self.assertIsInstance(StepRange.step, property)
        self.assertIsInstance(StepRange.stop, property)

    def test_unchangeable_attributes(self):
        """Test that the parameters return correct values and cannot change"""
        r = Range(40)
        sr = StepRange(40)
        sr_old = list(sr)
        for e in [r, sr]:
            with self.assertRaises(AttributeError):
                del e._params
            with self.assertRaises(AttributeError):
                e._params = {'start': 1, 'step': 4, 'stop': 40}
            with self.assertRaises(AttributeError):
                del e.start
            with self.assertRaises(AttributeError):
                e.start = 10
        self.assertEqual(sr.start, 40)
        self.assertEqual(sr.stop, 100)
        self.assertEqual(sr.step, 2)


class EnumerableTests(unittest.TestCase):

    enums = []
    for n in {4, 5}:
        enums.append(TreeEnumerator(n))
        enums.append(ForestEnumerator(n))
        enums.append(TransformationMonoid(n))
        enums.append(EndofunctionStructures(n))
    enums.extend([
        EndofunctionStructures(100, [3, 3, 2]),
        EndofunctionStructures(100, [1, 1, 2, 3])
    ])
    enums.extend([
        FixedContentNecklaces([3, 3, 2]),
        FixedContentNecklaces([1, 2, 1, 3]),
        PartitionForests([3, 3, 2]),
        PartitionForests([1, 3, 2, 1])
    ])

    def test_repr(self):
        """Test each enumerator correctly represents itself"""
        for enum in self.enums:
            self.assertEqual(enum, eval(repr(enum)))

    def test_eq(self):
        """Test each enumeration is unique"""
        for i, e1 in enumerate(self.enums):
            for j, e2 in enumerate(self.enums):
                if i == j:
                    self.assertEqual(e1, e2)
                else:
                    self.assertNotEqual(e1, e2)

    def test_hashability(self):
        """test each enum can be used as a unique hash"""
        dic = {}
        for i, e in enumerate(self.enums):
            dic[e] = i
        elen = len(dic)
        dic[EndofunctionStructures(100, [3, 3, 2])] = -2100
        self.assertEqual(elen, len(dic))
        self.assertIn(-2100, dic.values())
        dic[EndofunctionStructures(10)] = 1
        self.assertEqual(elen+1, len(set(dic)))

    def test_lower_bounds(self):
        """Ensure that negative enumerations raise errors"""
        with self.assertRaises(ValueError):
            TreeEnumerator(0)
        with self.assertRaises(ValueError):
            ForestEnumerator(-1)
        with self.assertRaises(ValueError):
            TransformationMonoid(-1)
        with self.assertRaises(ValueError):
            EndofunctionStructures(-1)
