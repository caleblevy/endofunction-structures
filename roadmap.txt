Early January 2015:

    # Modules with ACCEPTABLE NAMES from which NOTHING SHOULD BE REMOVED:
    #   - funcdists
    #   - funcstructs
    #   - rootedtrees
    #   - integerroots
    #   - necklaces
    #   - multiset
    #   - rotation (Maybe...)
    #   - polynomials (for now...)
    #
    # Modules with UNSUITABLE NAMES from which NOTHING SHOULD BE REMOVED:
    #   - primes -> should go to factor, factors, or factorization
    #   - monotones -> should be renamed to subseq, subsequence, or subsequences
    #   - nestops -> should be renamed to nesting, nests, something (Maybe...)
    #
    # Modules up for disassembly:
    #   - iteration: acknowledged at the time of its creation as a
    #     miscellaneous generator dump, it has to go.

January 31, 2015:

    # Ideas that should VERY LIKELY be persued:
    #   - Make RootedTrees collection class
    #     * __len__ will be rooted_treecount
    #     * __in__ will be rooted tree check'
    #     * __iter__ is the rooted_trees generator
    #     * __next__ is successor tree
    #   - Make a RootedTree object.
    #     * chop -> tree.chop()
    #     * tree_to_func -> tree.func_form()
    #     * canonical_treeorder -> tree.canonical_form()
    #     * len(tree) -> __len__
    #     * hypothetical is_tree function -> __eq__
    #     * Ordering -> __cmp__, __le__, __eq__
    #
    # Ideas that should POSSIBLY be explored:
    #   - Corresponding CanonicalRootedTree and CanonicalRootedTrees
    #   - LabelledRootedTree/UnlabelledRootedTree

February 2, 2015:

    # Ideas that should VERY LIKELY be pursued:
    #   - Make my own Multiset classes based off of the bag module.
    #   - Funcstruct class
    #   - Endofunction class
    #
    # Ideas that should PROBABLY be pursued
    #   - Forest class (derived from my custom Multiset classes)
    #   - Corresponding Canonical"..." classes with sorting methods.
    #   - Necklace classes.

February 4, 2015:

    # Trees:
    #   - Want to make forest class
    #   - Using this, add a splice method to produce a tree
    #   - Add a sort method to RootedTree to enable...
    #   - Making a Canonical Rooted Tree
    #   - Make a forest enumerator class
    #
    # Print:
    #   - Give that class string print.
    #   - Update multiset __repr__ to reflect __str__
    #
    # Necklaces:
    #   - Make a Necklace (Cycle?)class
    #   - Make Necklace enumerator (len gets wrapped in as necklace_count)
    #   - Give it a class method: From multiset (or it takes a multiset...)
    #
    # Funcstructs and Endofunctions
    #   - Make Multiset.partitions return multiset of multisets
    #   - Make Funcstruct class and Endofunction class
    #   - Make Funcstruct enumerator class (classmethod from func)

February 5, 2015:

    # - Replace RootedTree.bracket_form with RootedTree.set_form, and make it
    #   nested frozensets as I had originally intended.
    # - Replace O(n^2) preimage with O(n) set based preimage.

February 13 2015:

    # - Derive OrderedTree and DominantTree from the same BaseOrderedTree class.
    # - Update project directory structure.
    # - Separate unit tests into their own subdirectory.
    # - Add necklace enumeration paper to papers.
    #
    # Maybe:
    #   - Make RootedTree class sortable.
    #   - Resolve path dependency issues for PADS to work in python3.

      - Make iterdist_brute and iterdist_funcstruct into methods of their
        respective TransformationMonoid and FuncstructEnumerator classes. 
        (on hold for now.)

February 17, 2015:

    # - Incorporate alternate constructors directly into class __init__ methods
    # - Increase speed of modules and tests (in particular multiset) (sort of
    #   done).

February 24, 2015:

Things that should ALMOST CERTAINLY be implemented in one form or another:
  - Labelling method(s) for Funcstruct

Things that should be implemented and will PROBABLY WORK:
  - Find the conjugating function to get from one Endofunction to another.

Things THERE ARE GOOD REASONS TO BELIEVE ARE POSSIBLE:
  - Faster method computing iteration distributions using monomial symmetric
    polynomials in necklace periodicities.
  - Direct enumeration of representative endofunctions corresponding to
    structures (i.e. the lexicographically minimal endofunction).
    * Also consider finding the smallest endofunction for a given Funcstruct.

Structural refinement objectives:
  - Cleaning up labellings:
    * shortly/immediately: rename labellings.py -> cycle_labellings.py.
    * short/medium term: Unifying all labelling modules into labellings.py
    * soon/long term: distributing labelling methods in their respective
      combinatorial classes. potentially leaving behind some general
      combinatorial set functions.
  - Make TransformationMonoid accept a RootedTree and generate equivalent
    endofunctions; similar for Funcstructs.
  - Combine FuncstructEnumerator classes (and maybe forest).
  - Improve Funcstruct enumeration speed:
    * In particular, postponing translation of primitive object representatives
      into their proper classes for as long as possible should (hopefully)
      speed up enumerator classes.

Broader project roadmap:
  - Public release (~next couple weeks)
  - Distribute as package on PyPi (~next couple months)
  - Improve documentation and PEP8 compliance. (~next couple months)
  - Formal mathematical write-ups describing algorithms and data structures
    derived for this project. Most likely in Latex (Lyx). (~next 2-6 months)
  - Contact potentially interested parties in pursuing this project further.
  - Investigate publication of any project materials (~whenever contacting)
  - Translation to C (and/or C++, or JAVA). Or even Objective-C (why not?)

More flippant goals:
  - Give the code a little more style and flair

Modules that are getting a little too comfy, making me suspicious...
  - compositions.py (maybe, maybe not)
  - productrange.py (at the least may rename "products")
  - levypartitions.py (any more descriptive name?)
  - polynomials.py (combine with productrange?)
  - subsequences.py (is this really necessary?)
